# pyright: reportImplicitOverride=false, reportIncompatibleMethodOverride=false
from typing import overload

class CheckSatResult(object): ...

sat: CheckSatResult
unsat: CheckSatResult
unknown: CheckSatResult

class BoolRef(object):
    def __eq__(self, other: BoolRef) -> BoolRef: ...
    def __ne__(self, other: BoolRef) -> BoolRef: ...
    def __invert__(self) -> BoolRef: ...

def Bool(name: str) -> BoolRef: ...
def And(*args: BoolRef) -> BoolRef: ...
def Or(*args: BoolRef) -> BoolRef: ...
def Not(a: BoolRef) -> BoolRef: ...
def Implies(a: BoolRef, b: BoolRef) -> BoolRef: ...
def is_true(a: BoolRef) -> bool: ...
def is_false(a: BoolRef) -> bool: ...

class BitVecRef(object):
    def __eq__(self, other: BitVecRef) -> BoolRef: ...
    def __ne__(self, other: BitVecRef) -> BoolRef: ...
    def __gt__(self, other: BitVecRef) -> BoolRef: ...
    def __ge__(self, other: BitVecRef) -> BoolRef: ...
    def __lt__(self, other: BitVecRef) -> BoolRef: ...
    def __le__(self, other: BitVecRef) -> BoolRef: ...
    def __add__(self, other: BitVecRef) -> BitVecRef: ...
    def __sub__(self, other: BitVecRef) -> BitVecRef: ...
    def size(self) -> int: ...

def BitVec(name: str, bv: int) -> BitVecRef: ...
def Concat(*args: BitVecRef) -> BitVecRef: ...
def Extract(high: int, low: int, a: BitVecRef) -> BitVecRef: ...
@overload
def If(a: BoolRef, b: BitVecRef, c: BitVecRef) -> BitVecRef: ...

class BitVecNumRef(BitVecRef): ...

def BitVecVal(val: int, bv: int) -> BitVecNumRef: ...

class ArithRef(object):
    def __eq__(self, other: ArithRef | int) -> BoolRef: ...
    def __ne__(self, other: ArithRef | int) -> BoolRef: ...
    def __gt__(self, other: ArithRef | int) -> BoolRef: ...
    def __ge__(self, other: ArithRef | int) -> BoolRef: ...
    def __lt__(self, other: ArithRef | int) -> BoolRef: ...
    def __le__(self, other: ArithRef | int) -> BoolRef: ...
    def __add__(self, other: ArithRef | int) -> ArithRef: ...
    def __sub__(self, other: ArithRef | int) -> ArithRef: ...
    def __mul__(self, other: int) -> ArithRef: ...

def Int(name: str) -> ArithRef: ...
def IntVal(value: int) -> ArithRef: ...
@overload
def If(a: BoolRef, b: ArithRef, c: ArithRef) -> ArithRef: ...

class FPRef(object):
    def __eq__(self, other: FPRef) -> BoolRef: ...
    def __ne__(self, other: FPRef) -> BoolRef: ...

def fpFP(sgn: BitVecRef, exp: BitVecRef, sig: BitVecRef) -> FPRef: ...
def fpIsZero(a: FPRef) -> BoolRef: ...
def fpIsPositive(a: FPRef) -> BoolRef: ...
def fpIsNegative(a: FPRef) -> BoolRef: ...
def fpIsInf(a: FPRef) -> BoolRef: ...
def fpIsNaN(a: FPRef) -> BoolRef: ...
def fpIsSubnormal(a: FPRef) -> BoolRef: ...

class FPRMRef(object): ...

def RoundNearestTiesToEven() -> FPRMRef: ...
def fpAdd(rm: FPRMRef, a: FPRef, b: FPRef) -> FPRef: ...
def fpSub(rm: FPRMRef, a: FPRef, b: FPRef) -> FPRef: ...

class IntNumRef(object):
    def as_long(self) -> int: ...

class ModelRef(object):
    @overload
    def __getitem__(self, key: BoolRef) -> BoolRef: ...
    @overload
    def __getitem__(self, key: ArithRef) -> IntNumRef: ...

class Solver(object):
    def add(self, *args: BoolRef) -> None: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...
    def check(self) -> CheckSatResult: ...
    def model(self) -> ModelRef: ...
    def to_smt2(self) -> str: ...

def SolverFor(logic: str) -> Solver: ...
