from typing import overload, override

class CheckSatResult(object): ...

sat: CheckSatResult
unsat: CheckSatResult
unknown: CheckSatResult

class BoolRef(object):
    @override
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BoolRef
    ) -> BoolRef: ...
    @override
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BoolRef
    ) -> BoolRef: ...

def And(*args: BoolRef) -> BoolRef: ...
def Or(*args: BoolRef) -> BoolRef: ...
def Not(a: BoolRef) -> BoolRef: ...
def Implies(a: BoolRef, b: BoolRef) -> BoolRef: ...

class BitVecRef(object):
    @override
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BitVecRef
    ) -> BoolRef: ...
    @override
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BitVecRef
    ) -> BoolRef: ...
    def __gt__(self, other: BitVecRef) -> BoolRef: ...
    def __ge__(self, other: BitVecRef) -> BoolRef: ...
    def __lt__(self, other: BitVecRef) -> BoolRef: ...
    def __le__(self, other: BitVecRef) -> BoolRef: ...
    def __add__(self, other: BitVecRef) -> BitVecRef: ...
    def __sub__(self, other: BitVecRef) -> BitVecRef: ...
    def size(self) -> int: ...

def BitVec(name: str, bv: int) -> BitVecRef: ...

class BitVecNumRef(BitVecRef): ...

def BitVecVal(val: int, bv: int) -> BitVecNumRef: ...
def Concat(*args: BitVecRef) -> BitVecRef: ...
def Extract(high: int, low: int, a: BitVecRef) -> BitVecRef: ...
@overload
def If(a: BoolRef, b: BitVecRef, c: BitVecRef) -> BitVecRef: ...

class ArithRef(object):
    @override
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: ArithRef
    ) -> BoolRef: ...
    @override
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: ArithRef
    ) -> BoolRef: ...
    def __gt__(self, other: ArithRef) -> BoolRef: ...
    def __ge__(self, other: ArithRef) -> BoolRef: ...
    def __lt__(self, other: ArithRef) -> BoolRef: ...
    def __le__(self, other: ArithRef) -> BoolRef: ...
    def __add__(self, other: ArithRef) -> ArithRef: ...
    def __sub__(self, other: ArithRef) -> ArithRef: ...

@overload
def If(a: BoolRef, b: ArithRef, c: ArithRef) -> ArithRef: ...

class FPRef(object):
    @override
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: FPRef
    ) -> BoolRef: ...
    @override
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: FPRef
    ) -> BoolRef: ...

def fpFP(sgn: BitVecRef, exp: BitVecRef, sig: BitVecRef) -> FPRef: ...
def fpIsZero(a: FPRef) -> BoolRef: ...
def fpIsPositive(a: FPRef) -> BoolRef: ...
def fpIsNegative(a: FPRef) -> BoolRef: ...
def fpIsInf(a: FPRef) -> BoolRef: ...
def fpIsNaN(a: FPRef) -> BoolRef: ...
def fpIsSubnormal(a: FPRef) -> BoolRef: ...

class FPRMRef(object): ...

def RoundNearestTiesToEven() -> FPRMRef: ...
def fpAdd(rm: FPRMRef, a: FPRef, b: FPRef) -> FPRef: ...
def fpSub(rm: FPRMRef, a: FPRef, b: FPRef) -> FPRef: ...

class Solver(object):
    def add(self, *args: BoolRef) -> None: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...
    def to_smt2(self) -> str: ...

def SolverFor(logic: str) -> Solver: ...
